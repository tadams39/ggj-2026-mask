# Sled Character Controller Implementation Plan

## Overview
Create a physics-based sled character controller with a unique "keel" mechanic that resists lateral sliding until a slope threshold is exceeded, then allows controlled drifting.

## User Requirements
- **3 sphere colliders** in triangle formation (1 front, 2 rear) for realistic sled physics
- **Public fields** for parameters (no ScriptableObject)
- **Core features**: Movement, keel mechanic, debug visualization, speed-dependent steering
- **NO physics materials** in initial implementation

## Implementation Steps

### Step 1: Create SledController.cs Script
**File**: `Assets/Scripts/Player/SledController.cs`

**Core Components**:
- Rigidbody reference and configuration
- 3 sphere colliders setup (front, rear-left, rear-right)
- Input handling using legacy Input Manager
- Speed-dependent steering logic
- Integration with LevelGenerator.instance.playerTransform

**Rigidbody Configuration**:
```csharp
mass = 50f
drag = 0.5f
angularDrag = 2f
interpolation = Interpolate
collisionDetectionMode = ContinuousDynamic
constraints = FreezeRotationX | FreezeRotationZ  // Only Y-axis rotation
```

**Tunable Parameters** (public fields):
```csharp
[Header("Movement")]
accelerationPower = 15f
maxSpeed = 40f
steerStrength = 40f
brakeStrength = 2f

[Header("Keel Mechanic")]
lateralResistanceThreshold = 15f  // Degrees of slope
maxResistanceForce = 25f
driftCoefficient = 0.4f

[Header("Speed-Dependent Steering")]
minSteerFactor = 0.5f  // Steering multiplier at max speed
speedForFullReduction = 20f  // Speed at which steering is reduced
```

**Sphere Collider Positions**:
- Front: center = (0, 0.3, 0.8), radius = 0.3
- Rear Left: center = (-0.4, 0.3, -0.6), radius = 0.3
- Rear Right: center = (0.4, 0.3, -0.6), radius = 0.3

### Step 2: Create GroundDetector.cs Script
**File**: `Assets/Scripts/Player/GroundDetector.cs`

**Responsibilities**:
- Multi-point raycast system (5 rays: center, front, back, left, right)
- Ground normal calculation (averaged from hits)
- Slope angle computation (forward and lateral)
- Expose properties: `IsGrounded`, `GroundNormal`, `LateralSlope`, `ForwardSlope`

**Raycast Configuration**:
```csharp
raycastDistance = 1.5f
rayOrigin = transform.position + Vector3.up * 0.2f
layerMask = ~0  // Hit everything
```

**Raycast Pattern**:
- Center: (0, 0, 0)
- Front: transform.forward * 0.5
- Back: -transform.forward * 0.5
- Right: transform.right * 0.5
- Left: -transform.right * 0.5

### Step 3: Implement Core Movement in SledController
**FixedUpdate Logic**:
1. Read input axes (Horizontal, Vertical)
2. Apply steering with speed-dependent reduction:
   ```csharp
   speedFactor = Mathf.Clamp01(velocity.magnitude / speedForFullReduction)
   adjustedSteer = steerStrength * Mathf.Lerp(1f, minSteerFactor, speedFactor)
   AddTorque(Vector3.up * horizontal * adjustedSteer)
   ```
3. Apply acceleration/braking based on vertical input
4. Clamp velocity to maxSpeed

### Step 4: Implement Keel Mechanic
**Algorithm**:
1. Get lateral slope from GroundDetector
2. Calculate lateral velocity component (sideways sliding)
3. **IF** `abs(lateralSlope) < lateralResistanceThreshold`:
   - Apply strong counter-force to resist sliding
   - Force = `-lateralVelocity.normalized * min(lateralSpeed * 10, maxResistanceForce)`
   - Counter gravity's lateral component
4. **ELSE** (drift mode):
   - Apply weak counter-force for controlled drift
   - Force = `-lateralVelocity.normalized * lateralSpeed * driftCoefficient`
   - Allow gravity to contribute to drift

### Step 5: Implement Debug Visualization
**OnDrawGizmos Method**:
- Green line: Ground normal (2 units long)
- Blue/Red line: Lateral slope direction (blue = resisting, red = drifting)
- Yellow line: Current velocity vector (scaled by 0.5)
- Cyan spheres: Raycast hit points
- Magenta rays: Raycast directions

**Optional UI Debug Text**:
- Display: Speed, Lateral Slope, Keel State (Resisting/Drifting), IsGrounded

### Step 6: Integration with Existing Systems
**LevelGenerator Integration**:
- In `Start()`: Set `LevelGenerator.instance.playerTransform = transform`
- Ensure sled spawns at correct position/rotation from chunk anchors

**PlayerTrigger Setup**:
- Add child GameObject "TriggerDetector" to sled
- Attach BoxCollider (isTrigger = true) sized for chunk detection
- Attach PlayerTrigger.cs component
- Configure events in Inspector if needed

### Step 7: Create Sled Prefab
**Hierarchy**:
```
SledPlayer (GameObject)
├── Rigidbody
├── SledController.cs
├── GroundDetector.cs
├── SphereCollider (Front) - center (0, 0.3, 0.8)
├── SphereCollider (RearLeft) - center (-0.4, 0.3, -0.6)
├── SphereCollider (RearRight) - center (0.4, 0.3, -0.6)
└── TriggerDetector (Child GameObject)
    ├── BoxCollider (isTrigger = true)
    └── PlayerTrigger.cs
```

**Optional Visual Mesh**:
- Add sled 3D model as child (separate from physics colliders)
- Can apply visual lean based on steering input

### Step 8: Scene Setup
**Actions**:
1. Add SledPlayer prefab to scene
2. Position at `currentChunks[2].enterAnchor.position + Vector3.up`
3. Reference sled transform in LevelGenerator's `playerTransform` field (Inspector)
4. Verify chunks have appropriate colliders (convex mesh)

### Step 9: Testing & Tuning
**Test Sequence**:
1. Flat terrain: Basic movement, turning, acceleration
2. Moderate slope (<15°): Verify keel resistance prevents sliding
3. Steep slope (>15°): Verify drift behavior activates
4. Chunk transitions: Ensure smooth progression, no getting stuck
5. High speed: Check stability, collision detection, steering reduction

**Expected Tuning**:
- Adjust `lateralResistanceThreshold` for desired drift feel
- Tweak `maxResistanceForce` if sled is too sticky or too slippery
- Modify `steerStrength` and `minSteerFactor` for turning feel
- Balance `accelerationPower` and `drag` for speed curve

## Critical Files Modified/Created

### New Files:
- `Assets/Scripts/Player/SledController.cs` - Main controller (300-400 lines)
- `Assets/Scripts/Player/GroundDetector.cs` - Raycast utility (150-200 lines)

### Modified Files:
- `Assets/Scripts/LevelGenerator.cs` - Potentially update playerTransform reference in Inspector (no code changes needed)

### Assets Created:
- `Assets/Prefabs/SledPlayer.prefab` - Configured sled with all components

## Anticipated Challenges & Solutions

### Challenge: Jittery movement on uneven terrain
**Solution**: Use Rigidbody interpolation, smooth ground normals over 2-3 frames using exponential averaging

### Challenge: Getting stuck on chunk seams
**Solution**: Verify chunk exit/enter anchors align properly, add slight upward bias to forward force during transitions

### Challenge: Keel feels too binary (on/off)
**Solution**: Add smoothing transition zone around threshold:
```csharp
float keelFactor = InverseLerp(threshold - 5, threshold + 5, lateralSlope)
finalResistance = Lerp(maxResistance, driftResistance, keelFactor)
```

### Challenge: High-speed instability
**Solution**: Already mitigated by ContinuousDynamic collision detection; if needed, add speed-based drag increase

## Success Criteria
- ✅ Sled moves forward/backward with input
- ✅ Steering works with speed-dependent reduction
- ✅ Lateral resistance active on slopes < 15°
- ✅ Drift behavior triggers on slopes > 15°
- ✅ Smooth integration with chunk-based level system
- ✅ Debug visualization shows ground normals, velocity, keel state
- ✅ No tunneling through terrain at high speeds
- ✅ Responsive and fun to control

## Next Steps After Implementation
1. Playtest on various terrain slopes
2. Tune parameters based on feel
3. Consider adding boost mechanic or trick system
4. Add visual feedback (particles, lean animation)
5. Implement crash/wipeout detection if desired
